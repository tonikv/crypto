{"version":3,"sources":["components/DownwardTrend.js","utils.js","components/HighestTradingVolume.js","components/TimeMachine.js","components/DaysOfData.js","components/ShowData.js","components/DatePicker.js","components/Footer.js","App.js","index.js"],"names":["DownwardTrend","downwardTrend","className","getDailyPrices","data","currentDay","previousDay","currentPrice","previousPrice","pricesArray","len","prices","length","i","Date","getUTCDay","dataObject","toUTCString","push","utils","maxDownward","price","highestTradingVolume","totalVolume","indexHighestVolume","maxTotalVolume","total_volumes","bestTimeToBuyAndSell","bestProfit","profit","profitData","j","Intl","NumberFormat","style","currency","maximumFractionDigits","format","date","slice","getDataLength","dateStart","dateEnd","dayDifference","getTime","Math","round","daysBetweenTwoDates","HighestTradingVolume","volumeInEuros","total_volume","TimeMachine","canYouProfit","dateToBuy","priceToBuy","dateToSell","priceToSell","DaysOfData","days","ShowData","cryptoData","daysBetween","DatePicker","getData","onSubmit","e","preventDefault","target","from","value","to","fromDate","toDate","today","toDateString","getFullYear","console","log","dates","htmlFor","type","id","name","Footer","href","App","useState","undefined","setCryptoData","a","fetch","response","json","ReactDOM","render","StrictMode","document","getElementById"],"mappings":"gOAWeA,EATO,SAAC,GAAuB,IAArBC,EAAoB,EAApBA,cACrB,OACI,sBAAKC,UAAU,YAAf,UACI,mBAAGA,UAAU,cAAb,4CACA,oBAAGA,UAAU,YAAb,UAA0BD,EAA1B,eCDZ,SAASE,EAAeC,GAKpB,IAJA,IAEIC,EAAYC,EAAaC,EAAcC,EAFrCC,EAAc,GACdC,EAAMN,EAAKO,OAAOC,OAGfC,EAAI,EAAGA,EAAIH,EAAKG,IAAK,CAO1B,GANAR,EAAa,IAAIS,KAAKV,EAAKO,OAAOE,GAAG,IAAIE,YACzCR,EAAeH,EAAKO,OAAOE,GAAG,GAC9BP,EAAc,IAAIQ,KAAKV,EAAKO,OAAOE,EAAI,GAAG,IAAIE,YAC9CP,EAAgBJ,EAAKO,OAAOE,EAAI,GAAG,GAG/BR,IAAeC,EAAa,CAC5B,IAAMU,EAAa,CACf,KAAQ,IAAIF,KAAKV,EAAKO,OAAOE,EAAI,GAAG,IAAII,cACxC,MAAST,GAEbC,EAAYS,KAAKF,GAIrB,GAAIH,IAAMH,EAAM,EAAG,CACf,IAAMM,EAAa,CACf,KAAQ,IAAIF,KAAKV,EAAKO,OAAOE,GAAG,IAAII,cACpC,MAASV,GAEbE,EAAYS,KAAKF,IAGzB,OAAOP,EAwGX,IAQeU,EARD,CACVlB,cAjGJ,SAAuBG,GAInB,IAHA,IAAMO,EAASR,EAAeC,GAC1BH,EAAgB,EAChBmB,EAAc,EACTP,EAAI,EAAGA,EAAIF,EAAOC,OAAQC,IAAK,CACjBF,EAAOE,GAAGQ,MACTV,EAAOE,EAAI,GAAGQ,MAG9BpB,IAEAA,EAAgB,EAGhBA,EAAgBmB,IAChBA,EAAcnB,GAGtB,OAAOmB,GAgFPE,qBAzEJ,SAA8BlB,GAM1B,IALA,IAEImB,EAFAC,EAAqB,EACrBC,EAAiB,EAEjBf,EAAMN,EAAKsB,cAAcd,OAEpBC,EAAI,EAAGA,EAAIH,EAAKG,KACrBU,EAAcnB,EAAKsB,cAAcb,GAAG,IAClBY,IACdA,EAAiBF,EACjBC,EAAqBX,GAQ7B,MAJmB,CACf,KAAQ,IAAIC,KAAKV,EAAKsB,cAAcF,GAAoB,IAAIP,cAC5D,aAAgBb,EAAKsB,cAAcF,GAAoB,KA0D3DrB,iBACAwB,qBAlDJ,SAA8BvB,GAS1B,IARA,IAAMO,EAASR,EAAeC,GAC1BwB,EAAa,EACbC,EAAS,EACTC,EAAa,CACb,cAAgB,GAIXjB,EAAI,EAAGA,EAAIF,EAAOC,OAAS,EAAGC,IAEnC,IAAK,IAAIkB,EAAIlB,EAAI,EAAGkB,EAAIpB,EAAOC,OAAQmB,KAEnCF,EAASlB,EAAOoB,GAAGV,MAAQV,EAAOE,GAAGQ,OACxBO,IACTA,EAAaC,EACbC,EAAa,CACT,cAAgB,EAChB,OAAU,IAAIE,KAAKC,aAAa,QAAS,CAACC,MAAO,WAAYC,SAAU,MAAOC,sBAAuB,IAAIC,OAAOT,GAChH,UAAajB,EAAOE,GAAGyB,KAAKC,MAAM,EAAE,IACpC,WAAc,IAAIP,KAAKC,aAAa,QAAS,CAACC,MAAO,WAAYC,SAAU,MAAOC,sBAAuB,IAAIC,OAAO1B,EAAOE,GAAGQ,OAC9H,WAAcV,EAAOoB,GAAGO,KAAKC,MAAM,EAAE,IACrC,YAAe,IAAIP,KAAKC,aAAa,QAAS,CAACC,MAAO,WAAYC,SAAU,MAAOC,sBAAuB,IAAIC,OAAO1B,EAAOoB,GAAGV,SAM/I,OAAOS,GAuBPU,cAbJ,SAAuBpC,GACnB,IAAIM,EAAMN,EAAKO,OAAOC,OAGtB,OAVJ,SAA6B6B,EAAWC,GACpC,IACMC,GADiB,IAAI7B,KAAK4B,GAASE,UAAY,IAAI9B,KAAK2B,GAAWG,WACrC,MACpC,OAAOC,KAAKC,MAAMH,GAOXI,CAFS3C,EAAKO,OAAO,GAAG,GACjBP,EAAKO,OAAOD,EAAM,GAAG,MCxHxBsC,EAXc,SAAC,GAA8B,IAA5B1B,EAA2B,EAA3BA,qBACtB2B,EAAgB,IAAIjB,KAAKC,aAAa,QACxC,CAACC,MAAO,WAAYC,SAAU,MAAOC,sBAAuB,IAAIC,OAAOf,EAAqB4B,cAChG,OACI,sBAAKhD,UAAU,YAAf,UACI,mBAAGA,UAAU,cAAb,wCACA,oBAAGA,UAAU,YAAb,UAA0BoB,EAAqBgB,KAAKC,MAAM,EAAE,IAA5D,IAAiE,uBAAjE,IAA4EU,EAA5E,WCsBGE,EAjBK,SAAC,GAAoB,IAAlBrB,EAAiB,EAAjBA,WACnB,OACI,sBAAK5B,UAAU,YAAf,UACI,mBAAGA,UAAU,cAAb,+CACC4B,EAAWsB,aACR,oBAAGlD,UAAU,YAAb,UACK4B,EAAWuB,UADhB,aACqCvB,EAAWwB,WAAW,uBACtDxB,EAAWyB,WAFhB,cAEuCzB,EAAW0B,YAAY,uBAF9D,0BAG4B1B,EAAWD,UAGvC,sDCdD4B,EARI,SAAC,GAAc,IAAZC,EAAW,EAAXA,KAClB,OACI,qBAAKxD,UAAU,YAAf,SACI,oBAAGA,UAAU,cAAb,cAA6BwD,EAA7B,sBCuCGC,EA/BE,SAAC,GAAoB,IAAlBC,EAAiB,EAAjBA,WAChB,IAAKA,EACD,OACI,qBAAK1D,UAAU,YAAf,SACI,mBAAGA,UAAU,cAAb,sFAIZ,IAAM2D,EAAc1C,EAAMqB,cAAcoB,GAClCxC,EAAcD,EAAMlB,cAAc2D,GAClCtC,EAAuBH,EAAMG,qBAAqBsC,GAClD9B,EAAaX,EAAMQ,qBAAqBiC,GAE9C,OACI,qCACI,cAAC,EAAD,CACIF,KAAMG,IAEV,cAAC,EAAD,CACI5D,cAAemB,IAEnB,cAAC,EAAD,CACIE,qBAAsBA,IAE1B,cAAC,EAAD,CACIQ,WAAYA,QCgCbgC,EA7DI,SAAC,GAAiB,IAAfC,EAAc,EAAdA,QAgDlB,OACI,qBAAK7D,UAAU,sBAAf,SACI,uBAAM8D,SAhDd,SAAuBC,GAInB,GAHAA,EAAEC,iBAGED,EAAEE,OAAOC,KAAKC,OAAUJ,EAAEE,OAAOG,GAAGD,MAAxC,CAMC,IAAME,EAAW,IAAIzD,KAAKmD,EAAEE,OAAOC,KAAKC,OAClCG,EAAS,IAAI1D,KAAKmD,EAAEE,OAAOG,GAAGD,OAC9BI,EAAQ,IAAI3D,KAGlB,GAAGyD,EAASG,iBAAmBF,EAAOE,eAMtC,GAAGH,EAASI,cAAgB,KACxBC,QAAQC,IAAI,oCAKhB,GAAGN,EAAWC,EACVI,QAAQC,IAAI,iCAKhB,GAAGN,EAAWE,GAASD,EAASC,EAC5BG,QAAQC,IAAI,iCADhB,CAKA,IAAMC,EAAQ,CACV,KAAQP,EAAS3B,UAAY,IAC7B,GAAO4B,EAAO5B,UAAY,IAAQ,MAGtCmB,EAAQe,QA3BNF,QAAQC,IAAI,yCAXXD,QAAQC,IAAI,0BA2CZ,UACI,uBAAOE,QAAQ,OAAf,yBAAyC,uBACzC,uBAAO7E,UAAU,aAAa8E,KAAK,OAAOC,GAAG,OAAOC,KAAK,SAAe,uBACxE,uBAAOH,QAAQ,KAAf,uBAAqC,uBACrC,uBAAO7E,UAAU,aAAa8E,KAAK,OAAOC,GAAG,KAAKC,KAAK,OAAa,uBACpE,wBAAQF,KAAK,SAAS9E,UAAU,cAAhC,qCCtDDiF,EARA,WACX,OACI,sBAAKjF,UAAU,SAAf,UACI,mBAAGkF,KAAK,4BAAR,gCADJ,oCCiCOC,MA/Bf,WACE,MAAoCC,wBAASC,GAA7C,mBAAO3B,EAAP,KAAmB4B,EAAnB,KADa,4CAGb,WAAuBV,GAAvB,iBAAAW,EAAA,sEACyBC,MAAM,0FAAD,OACgEZ,EAAMV,KADtE,eACiFU,EAAMR,KAFrH,cACQqB,EADR,gBAIqBA,EAASC,OAJ9B,QAIQxF,EAJR,QAKWO,OAAOC,OAAS,EACvB4E,EAAcpF,GAEdwE,QAAQC,IAAI,qCARhB,4CAHa,sBAeb,OACE,sBAAK3E,UAAU,MAAf,UACE,wBAAQA,UAAU,aAAlB,6BAGE,cAAC,EAAD,CACE6D,QArBK,8CAuBP,cAAC,EAAD,CACEH,WAAYA,IAEhB,cAAC,EAAD,QC5BNiC,IAASC,OACP,cAAC,IAAMC,WAAP,UACE,cAAC,EAAD,MAEFC,SAASC,eAAe,W","file":"static/js/main.653af41b.chunk.js","sourcesContent":["// UI Element to show downward trend \r\n\r\nconst DownwardTrend = ( {downwardTrend} ) => {\r\n    return (\r\n        <div className=\"info-card\">\r\n            <p className=\"info-header\">Longest downward bearing trend</p>\r\n            <p className=\"info-text\">{downwardTrend} days</p>\r\n        </div>\r\n    )\r\n}\r\n\r\nexport default DownwardTrend\r\n","/* Process the data to get the prices for the day (closest to 00:00 UTC time). Return them as object with following keys\r\n    This works with different data granularity's that the API is using. So we can always pass the data here to get prices closest to 00:00 UTC time.\r\n    \"date\": full date string format\r\n    \"price\": price closest to 00:00 UTC\r\n*/\r\nfunction getDailyPrices(data) {\r\n    const pricesArray = [];\r\n    const len = data.prices.length;\r\n    let currentDay, previousDay, currentPrice, previousPrice\r\n\r\n    for (let i = 1; i < len; i++) {\r\n        currentDay = new Date(data.prices[i][0]).getUTCDay();\r\n        currentPrice = data.prices[i][1];\r\n        previousDay = new Date(data.prices[i - 1][0]).getUTCDay();\r\n        previousPrice = data.prices[i - 1][1];\r\n\r\n        // Get the last element of day\r\n        if (currentDay !== previousDay) {\r\n            const dataObject = {\r\n                \"date\": new Date(data.prices[i - 1][0]).toUTCString(),\r\n                \"price\": previousPrice, \r\n            }\r\n            pricesArray.push(dataObject)\r\n        }\r\n\r\n        // Get the last element of the array\r\n        if (i === len - 1) {\r\n            const dataObject = {\r\n                \"date\": new Date(data.prices[i][0]).toUTCString(),\r\n                \"price\": currentPrice, \r\n            }\r\n            pricesArray.push(dataObject)\r\n        }\r\n    }\r\n    return pricesArray;\r\n}\r\n\r\n/* A. How many days is the longest bearish (downward) trend within given data range\r\n 1. Parse data to daily format\r\n 2. Loop through and keep track if prices are dropping or rising. \r\n 3. Return longest trending trend\r\n*/\r\nfunction downwardTrend(data) {\r\n    const prices = getDailyPrices(data); // Parse data to daily format\r\n    let downwardTrend = 0;\r\n    let maxDownward = 0;\r\n    for (let i = 1; i < prices.length; i++) {\r\n        let currentPrice = prices[i].price;\r\n        let previousPrice = prices[i - 1].price;\r\n\r\n        if (currentPrice < previousPrice) {\r\n            downwardTrend++;\r\n        } else {\r\n            downwardTrend = 0;\r\n        }\r\n\r\n        if (downwardTrend > maxDownward) {\r\n            maxDownward = downwardTrend;\r\n        }\r\n    }\r\n    return maxDownward;\r\n}\r\n\r\n/* B. Which date within a given date range had the highest trading volume\r\n 1. Loop through and find highest value in the array. Store index of that element\r\n 2. Return that element\r\n*/\r\nfunction highestTradingVolume(data) {\r\n    let indexHighestVolume = 0;\r\n    let maxTotalVolume = 0;\r\n    let totalVolume;\r\n    let len = data.total_volumes.length;\r\n\r\n    for (let i = 0; i < len; i++) {\r\n        totalVolume = data.total_volumes[i][1];\r\n        if (totalVolume > maxTotalVolume) {\r\n            maxTotalVolume = totalVolume;\r\n            indexHighestVolume = i;\r\n        } \r\n    }\r\n\r\n    const dataObject = {\r\n        \"date\": new Date(data.total_volumes[indexHighestVolume][0]).toUTCString(),\r\n        \"total_volume\": data.total_volumes[indexHighestVolume][1], \r\n    }\r\n    return dataObject;\r\n}\r\n\r\n/* C. Time machine Best time to but and sell withing given date range\r\n 1. Parse data to daily format\r\n 2. Brute Force to find best dates.\r\n*/\r\nfunction bestTimeToBuyAndSell(data) {\r\n    const prices = getDailyPrices(data); // Parse data to daily format\r\n    let bestProfit = 0;\r\n    let profit = 0;\r\n    let profitData = {\r\n        \"canYouProfit\": false\r\n    };\r\n\r\n    // Loop from beginning to second to last element\r\n    for (let i = 0; i < prices.length - 1; i++) {\r\n        // Run nested loop so that we get every element after outer loops index\r\n        for( let j = i + 1; j < prices.length; j++) {\r\n            // Check price difference and check if it's bigger than previous best profit.\r\n            profit = prices[j].price - prices[i].price;\r\n            if (profit > bestProfit) {\r\n                bestProfit = profit;\r\n                profitData = {\r\n                    \"canYouProfit\": true,\r\n                    \"profit\": new Intl.NumberFormat('fi-FI', {style: 'currency', currency: 'EUR', maximumFractionDigits: 0}).format(bestProfit),\r\n                    \"dateToBuy\": prices[i].date.slice(0,16),\r\n                    \"priceToBuy\": new Intl.NumberFormat('fi-FI', {style: 'currency', currency: 'EUR', maximumFractionDigits: 0}).format(prices[i].price),\r\n                    \"dateToSell\": prices[j].date.slice(0,16),\r\n                    \"priceToSell\": new Intl.NumberFormat('fi-FI', {style: 'currency', currency: 'EUR', maximumFractionDigits: 0}).format(prices[j].price),\r\n                }\r\n            }\r\n        }\r\n    }\r\n\r\n    return profitData;\r\n}\r\n\r\n/* Functions to get data range in days */\r\nfunction daysBetweenTwoDates(dateStart, dateEnd) {\r\n    const timeDifference = new Date(dateEnd).getTime() - new Date(dateStart).getTime();\r\n    const dayDifference = timeDifference / (1000 * 60 * 60 * 24);  \r\n    return Math.round(dayDifference);\r\n}\r\n\r\nfunction getDataLength(data) {\r\n    let len = data.prices.length;\r\n    let dateStart = data.prices[0][0];\r\n    let dateEnd = data.prices[len - 1][0];\r\n    return daysBetweenTwoDates(dateStart, dateEnd);\r\n}\r\n\r\n\r\nconst utils = {\r\n    downwardTrend,\r\n    highestTradingVolume,\r\n    getDailyPrices,\r\n    bestTimeToBuyAndSell,\r\n    getDataLength\r\n}\r\n\r\nexport default utils\r\n","// UI Element to show highest trading volume date trend \r\n\r\nconst HighestTradingVolume = ( {highestTradingVolume} ) => {\r\n    const volumeInEuros = new Intl.NumberFormat('fi-FI', \r\n        {style: 'currency', currency: 'EUR', maximumFractionDigits: 0}).format(highestTradingVolume.total_volume);\r\n    return (\r\n        <div className=\"info-card\">\r\n            <p className=\"info-header\">Highest Trading Volume 24h</p>\r\n            <p className=\"info-text\">{highestTradingVolume.date.slice(0,16)} <br></br> {volumeInEuros} </p>\r\n        </div>\r\n    )\r\n}\r\n\r\nexport default HighestTradingVolume\r\n","/*\r\nUI Element to show should you buy and sell between data range \r\n\r\nprofitData = {\r\n    \"canYouProfit\": boolean\r\n    \"profit\": number,\r\n    \"dateToBuy\": date string\r\n    \"priceToBuy\": number\r\n    \"dateToSell\": date string\r\n    \"priceToSell\": number\r\n\r\n*/\r\n\r\nconst TimeMachine = ( {profitData} ) => {\r\n    return (\r\n        <div className=\"info-card\"> \r\n            <p className=\"info-header\">Best time to buy and sell Bitcoin</p>\r\n            {profitData.canYouProfit ? \r\n                <p className=\"info-text\">\r\n                    {profitData.dateToBuy} buy with {profitData.priceToBuy}<br></br>\r\n                    {profitData.dateToSell} sell with {profitData.priceToSell}<br></br>\r\n                    Profit for one Bitcoin {profitData.profit}\r\n                </p>\r\n                :\r\n                <p>You cannot profit</p>\r\n            }\r\n        </div>\r\n    )\r\n}\r\n\r\nexport default TimeMachine\r\n","// UI element to so data length in days \r\n\r\nconst DaysOfData = ( {days} ) => {\r\n    return (\r\n        <div className=\"info-card\">\r\n            <p className=\"info-header\"> {days} days of data</p>\r\n        </div>\r\n    )\r\n}\r\n\r\nexport default DaysOfData\r\n","/*\r\n    Component to pass the data in to and render it \r\n    First check that is data available. After that we process data to answer requested properties of Bitcoin\r\n\r\n */\r\n\r\n\r\nimport DownwardTrend from './DownwardTrend';\r\nimport utils from '../utils';\r\nimport HighestTradingVolume from './HighestTradingVolume';\r\nimport TimeMachine from './TimeMachine';\r\nimport DaysOfData from './DaysOfData';\r\n\r\nconst ShowData = ( {cryptoData} ) => {\r\n    if (!cryptoData) {\r\n        return (\r\n            <div className=\"info-card\">\r\n                <p className=\"info-header\"> Enter dates to get information from coinGecko API conserning Bitcoin </p>\r\n            </div>)\r\n    }\r\n\r\n    const daysBetween = utils.getDataLength(cryptoData);\r\n    const maxDownward = utils.downwardTrend(cryptoData);\r\n    const highestTradingVolume = utils.highestTradingVolume(cryptoData);\r\n    const profitData = utils.bestTimeToBuyAndSell(cryptoData);\r\n\r\n    return (\r\n        <>\r\n            <DaysOfData\r\n                days={daysBetween}\r\n            ></DaysOfData>\r\n            <DownwardTrend\r\n                downwardTrend={maxDownward}\r\n            ></DownwardTrend>\r\n            <HighestTradingVolume\r\n                highestTradingVolume={highestTradingVolume}\r\n            ></HighestTradingVolume>\r\n            <TimeMachine\r\n                profitData={profitData}\r\n            ></TimeMachine>\r\n        </>\r\n    )\r\n}\r\n\r\nexport default ShowData;","/*\r\n    Component for user to pick date range to use in coinGecko API query.\r\n    Basic form element with two input with date type.\r\n    We validate inputs before passing them to getData function. \r\n    \r\n    Todo:\r\n    errors in inputs are only console logged. Create component to show user that information in UI.\r\n*/\r\n\r\nconst DatePicker = ( {getData} ) => {\r\n\r\n    function validateDates(e) {\r\n        e.preventDefault();\r\n\r\n        //Check that user has given both dates\r\n        if(!e.target.from.value && !e.target.to.value) {\r\n            console.log(\"ERROR: Missing value!\");\r\n            return;\r\n         }\r\n\r\n         // Get dates from input fields and convert to Date objects for validation\r\n         const fromDate = new Date(e.target.from.value);\r\n         const toDate = new Date(e.target.to.value);\r\n         const today = new Date();\r\n         \r\n         //Check that dates aren't same\r\n         if(fromDate.toDateString() === toDate.toDateString()) {\r\n           console.log(\"ERROR: Give two different dates!\");\r\n           return;\r\n         }\r\n\r\n         // coinGecko has data beginning in 2013 so do not allow inputs before that\r\n         if(fromDate.getFullYear() < 2013) {\r\n             console.log(\"ERROR: No data before 2013!\")\r\n            return;\r\n         }\r\n     \r\n         //Check that start is before end\r\n         if(fromDate > toDate) {\r\n             console.log(\"ERROR: Start before end!\");\r\n             return;\r\n         }\r\n\r\n         // Check that dates are't in future\r\n         if(fromDate > today || toDate > today) {\r\n             console.log(\"ERROR: No data in future!\");\r\n             return;\r\n         }\r\n\r\n         const dates = {\r\n             \"from\": fromDate.getTime() / 1000,\r\n             \"to\": (toDate.getTime() / 1000) + 1600 // Add one hour to timestamp to make sure that we get data for end date as well\r\n         }\r\n\r\n         getData(dates)\r\n    }\r\n\r\n    return (\r\n        <div className=\"date-form-container\">\r\n            <form onSubmit={validateDates}>\r\n                <label htmlFor=\"from\">Start Date:</label><br></br>\r\n                <input className=\"date-input\" type=\"date\" id=\"from\" name=\"from\"></input><br></br>\r\n                <label htmlFor=\"to\">End Date:</label><br></br>\r\n                <input className=\"date-input\" type=\"date\" id=\"to\" name=\"to\"></input><br></br>\r\n                <button type=\"submit\" className=\"date-button\">Get Data from API</button>\r\n            </form>\r\n        </div>\r\n    )\r\n}\r\n\r\nexport default DatePicker\r\n","// UI Element for footer\r\n\r\nconst Footer = () => {\r\n    return (\r\n        <div className=\"footer\">\r\n            <a href=\"https://github.com/tonikv\"> Created by tonikv</a> - Data provided by CoinGecko\r\n        </div>\r\n    )\r\n}\r\n\r\nexport default Footer\r\n","import './App.css';\nimport { useState } from 'react'\nimport ShowData from './components/ShowData';\nimport DatePicker from './components/DatePicker';\nimport Footer from './components/Footer';\n\nfunction App() {\n  const [cryptoData, setCryptoData] = useState(undefined);\n\n  async function getData(dates) {\n    const response = await fetch(\n      `https://api.coingecko.com/api/v3/coins/bitcoin/market_chart/range?vs_currency=eur&from=${dates.from}&to=${dates.to}`);\n\n    const data = await response.json()\n    if (data.prices.length > 0) {\n      setCryptoData(data);\n    } else {\n      console.log(\"ERROR: No data in that data range\")\n    }\n}\n\n  return (\n    <div className=\"App\">\n      <header className=\"App-header\">\n        CRYPTO ANALYZER\n      </header>\n        <DatePicker\n          getData={getData}\n        />\n        <ShowData\n          cryptoData={cryptoData}\n        />\n      <Footer></Footer>\n    </div>\n  );\n}\n\nexport default App;\n","import React from 'react';\nimport ReactDOM from 'react-dom';\nimport App from './App';\n\nReactDOM.render(\n  <React.StrictMode>\n    <App />\n  </React.StrictMode>,\n  document.getElementById('root')\n);\n\n"],"sourceRoot":""}